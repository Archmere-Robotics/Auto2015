#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S4,    HTSMux,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          sweeper,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          heartbeat,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     wheelC,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     wheelD,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     wheelB,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     wheelA,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     collectorMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     liftMotor,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    rightHook,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    dumpServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    rightIRServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    leftIRServo,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "libHolonomics.c"
#include "ht-drivers\hitechnic-sensormux.h"
#define IRLEFT
#define IRRIGHT
const tMUXSensor IRLeft=msensor_S1_1;
const tMUXSensor IRRight=msensor_S1_2;
#include "cdrivers\IRSeekerLib.h"
#include "JoystickDriver.c"

#define IR_TOLERANCE 25
#define MAX_SPEED 55
#define MIN_SPEED 10//lowest speed still moves
#define SLOW_DOWN 700
#define LIFT_SPEED_STOP 0//speed
#define LIFT_SPEED_UP 30//speed whwhile holding
#define LIFT_SPEED_DOWN -3
#define LIFT_BOTTOM 500
#define LIFT_SLOW_DOWN 100
#define HOLD_POS 172
#define DUMP_POS 148
#define TILT_POS 190


//position variables for all autos
#define FORWARD_DRIVE 3000//distance to drive forward at the beginning of auto
#define RIGHT_ALIGN 1200//distance to ram side of goal
#define RIGHT_REALIGN 350//distance to back up and score
#define HIGH_GOAL 3550


//variables for auto1
#define ONE_LEFT_DRIVE 4000
#define ONE_FORWARD_DRIVE 2150

//variables for auto2
#define TWO_SPIN 1800
#define TWO_BACK_DRIVE 600
#define TWO_LEFT 1200

//variables for auto3
#define THREE_SPIN 1800
#define THREE_BACK 570

//variables for knocking down the post
#define KD_FOREWARD 500
#define KD_LEFT 1000
#define KD_SPIN 1000
void action(const string s) {
	displayCenteredTextLine(3,s);
}
void driveForward(int aTicks) {
	int offset = nMotorEncoder[wheelC];
	int speed=0;
	bool changeSpeed=true;//increases speed every other update
	while(nMotorEncoder[wheelC]-offset < aTicks/2) {//ramps up speed for just first half of distance
		if(speed<MAX_SPEED&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(-speed,-speed,speed,speed);
		wait1Msec(5);
	}
	while(nMotorEncoder[wheelC]-offset < aTicks) {
		if(speed>MIN_SPEED&& nMotorEncoder[wheelC]-offset > aTicks-SLOW_DOWN ) speed--;//if close enough to target to use slow down, will slow
		cDir(-speed,-speed,speed,speed);
		wait1Msec(5);
	}
	cDir(0,0,0,0);
}

void driveBackward(int aTicks) {
	int offset = nMotorEncoder[wheelB];
	int speed=0;
	bool changeSpeed = true;//increases speed every other update
	while(nMotorEncoder[wheelB]-offset < aTicks/2) {//ramps up speed for first half
		if(speed<MAX_SPEED&&changeSpeed){
			speed++
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(speed,speed,-speed,-speed);
		wait1Msec(5);
	}
	while(nMotorEncoder[wheelB]-offset < aTicks) {
		if(speed>MIN_SPEED&&nMotorEncoder[wheelB]-offset>aTicks-SLOW_DOWN)speed--;//if close enough to target to use slow down, will slow
		cDir(speed,speed,-speed,-speed);
		wait1Msec(5);
	}
	cDir(0,0,0,0);
}

void goLeft(int aTicks) {
	int offset = nMotorEncoder[wheelA];
	int speed=0;
	bool changeSpeed=true;//only increases speed every other update
	while(nMotorEncoder[wheelA]-offset < aTicks/2) {
		if(speed<MAX_SPEED&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(speed,-speed,-speed,speed);
		wait1Msec(5);
	}
	while(nMotorEncoder[wheelA]-offset < aTicks) {
		if(speed>MIN_SPEED&&nMotorEncoder[wheelA]-offset> aTicks-SLOW_DOWN)speed--;
		cDir(speed,-speed,-speed,speed);
		wait1Msec(5);
	}
	cDir(0,0,0,0);
}

void goRight(int aTicks) {
	int offset = nMotorEncoder[wheelB];
	int speed=0;
	bool changeSpeed=true;
	while(nMotorEncoder[wheelB]-offset < aTicks/2) {
		if(speed<MAX_SPEED&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(-speed,speed,speed,-speed);
		wait1Msec(5);
	}
	while(nMotorEncoder[wheelB]-offset < aTicks) {
		if(speed>MIN_SPEED&&nMotorEncoder[wheelB]-offset> aTicks-SLOW_DOWN)speed--;
		cDir(speed,-speed,-speed,speed);
		wait1Msec(5);
	}
	cDir(0,0,0,0);
}

void spinRight(int aTicks){
	int offset = nMotorEncoder[wheelA];
	int speed=0;
	bool changeSpeed=true;
	while(abs(nMotorEncoder[wheelA]-offset) < aTicks/2) {
		if(speed<MAX_SPEED&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(-speed,-speed,-speed,-speed);
		wait1Msec(5);
	}
	while(abs(nMotorEncoder[wheelA]-offset) < aTicks) {
		if(speed>MIN_SPEED&&abs(nMotorEncoder[wheelA]-offset)>aTicks-SLOW_DOWN)speed--;
		cDir(-speed,-speed,-speed,-speed);
		wait1Msec(5);
	}
	cDir(0,0,0,0);
}
void realign() {
	action("Realigning");
	int offset = nMotorEncoder[wheelB];
	int speed=0;
	bool changeSpeed=true;
	while(nMotorEncoder[wheelB]-offset < RIGHT_ALIGN) {
		if(speed<MAX_SPEED&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(-speed,speed,speed,-speed);
	}
	cDir(0,0,0,0);
	wait1Msec(100);
	offset = nMotorEncoder[wheelB];
	speed=0;
	changeSpeed=true;
	while(abs(nMotorEncoder[wheelB]-offset) < RIGHT_REALIGN/2) {
		if(speed<25&&changeSpeed){
			speed++;
			changeSpeed=false;
		}
		else changeSpeed=true;
		cDir(speed,-speed,-speed,speed);
		wait1Msec(10);
	}
	while(abs(nMotorEncoder[wheelB]-offset) <RIGHT_REALIGN) {
		if(speed>MIN_SPEED&&abs(nMotorEncoder[wheelA]-offset)>SLOW_DOWN)speed--;
		cDir(speed,-speed,-speed,speed);
		wait1Msec(10);
	}
	cDir(0,0,0,0);
}
int sampleHigh(int sensor,int samples) {
	int max=0;
	for(int i=0;i<samples;i++) {
		udVal();
		max=(max>lacValues[sensor])?max:lacValues[sensor];
		wait1Msec(5);
	}
	return max;
}
int getCenterThingPos() {
	action("Getting Position");
	return 1;
	int answer = 1;
	bool ir1 = sampleHigh(1,10)>IR_TOLERANCE,ir2=sampleHigh(2,10)>IR_TOLERANCE;
	if(ir1&&ir2)
		answer=3;//position 3 if IR beacon directly ahead
	else if(ir1||ir2)
		answer=2;//position 2 if IR beacons to mid left and right (left more detectable)
	displayString(0,"Pos:%d,1:%d,2:%d",answer,lacValues[1],lacValues[2]);
	for(int i=0;i<answer;i++){
		motor[heartbeat]=100;
		wait1Msec(250);
		motor[heartbeat]=0;
		wait1Msec(250);
	}
	return answer;
}

void raise(int height){
	int speed = 0;
	while(nMotorEncoder[liftMotor] < height-LIFT_SLOW_DOWN){//speed up and majority of movement
		if(speed<LIFT_SPEED_UP)
			speed++;
		motor[liftMotor]=speed;
	}
	while(nMotorEncoder[liftMotor] < height){//lift motor not yet at target
		if(speed>5)
			speed--;
		motor[liftMotor]=speed;
	}
	motor[liftMotor]=LIFT_SPEED_STOP;
	wait1Msec(500);
}
void tilt(){
	action("Tilting");
	int temp=servo[dumpServo];
	while(servo[dumpServo]<TILT_POS){
		servo[dumpServo]=temp++;
		wait1Msec(10);
	}
	wait1Msec(500);
}
void dump(){
	action("Dumping");
	int temp=servo[dumpServo];
	while(servo[dumpServo]>DUMP_POS){
		servo[dumpServo]=temp--;
		wait1Msec(10);
	}
	wait1Msec(3000);
	tilt();
}

void lower(){
	while(nMotorEncoder[liftMotor] > LIFT_BOTTOM){//lift motor not yet at target
		motor[liftMotor]=LIFT_SPEED_DOWN;
	}
	motor[liftMotor]=LIFT_SPEED_STOP;
}
void knockdownBalls() {
	driveForward(KD_FOREWARD);
	goLeft(KD_LEFT);
	spinRight(KD_SPIN);
}
void init(){
	action("Initializing");
	nMotorEncoder[wheelA]=0;nMotorEncoder[wheelB]=0;nMotorEncoder[wheelC]=0;nMotorEncoder[wheelD]=0;nMotorEncoder[liftMotor]=0;
	servoChangeRate[dumpServo]=1;
	servo[dumpServo]=HOLD_POS;
	servo[leftIRServo]=LEFT_SERVO_POS;
	servo[rightIRServo]=RIGHT_SERVO_POS;
	servo[rightHook]=RIGHT_HOOK_DOWN;
	wait1Msec(100);
	raise(LIFT_BOTTOM);
	wait1Msec(100);
}

task main() {
	action("Waiting...");
	//waitForStart();
	init();

	//driveForward(FORWARD_DRIVE);
	switch(getCenterThingPos()) {
	case 1:
		//goLeft(ONE_LEFT_DRIVE);
		//driveForward(ONE_FORWARD_DRIVE);
		//realign();
		tilt();
		raise(HIGH_GOAL);
		wait1Msec(2000);
		dump();
		break;
	case 2:
		goLeft(TWO_LEFT);
		spinRight(TWO_SPIN);
		driveBackward(TWO_BACK_DRIVE);
		realign();
		raise(HIGH_GOAL);
		dump();
		break;
	case 3:
		spinRight(THREE_SPIN);
		driveBackward(THREE_BACK);
		realign();
		raise(HIGH_GOAL);
		dump();
		break;
	default:
		break;
	}
	lower();
	//knockdownBalls();
}
