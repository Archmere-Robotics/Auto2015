#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          heartbeat,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          leftHook,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightHook,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     wheelB,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     wheelA,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     collectorMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     liftMotor,     tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     wheelC,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     wheelD,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    dumpServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    doorServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "libHolonomics.c"

#define MAX_SPEED 100
#define MIN_SPEED 5//lowest speed still moves
#define SLOW_DOWN 1500


#define FORWARD_DRIVE 4500//distance to drive forward at the beginning of auto
#define LEFT_ALIGN 1000//distance to ram side of goal
#define LEFT_REALIGN 500//idstance to back up and score

#define ONE_LEFT_DRIVE 3500//for 1
#define ONE_SPIN 5100//for 1
#define ONE_BACK_DRIVE 2000

#define TWO_SPIN 11000
#define TWO_BACK_DRIVE 2000

#define THREE_SPIN 2500

void driveForward(int aTicks) {
	int offset = nMotorEncoder[wheelC];
	int speed=0;
	while(nMotorEncoder[wheelC]-offset < aTicks-SLOW_DOWN) {
		if(speed<MAX_SPEED)speed++;
		cDir(-speed,-speed,speed,speed);
	}
	while(nMotorEncoder[wheelC]-offset < aTicks) {
		if(speed>5)speed--;
		cDir(-speed,-speed,speed,speed);
	}
	cDir(0,0,0,0);
}

void driveBackward(int aTicks) {
	int offset = nMotorEncoder[wheelB];
	int speed=0;
	while(nMotorEncoder[wheelB]-offset < aTicks-SLOW_DOWN) {
		if(speed<MAX_SPEED)speed++;
		cDir(speed,speed,-speed,-speed);
	}
	while(nMotorEncoder[wheelB]-offset < aTicks) {
		if(speed>5)speed--;
		cDir(speed,speed,-speed,-speed);
	}
	cDir(0,0,0,0);
}

void goLeft(int aTicks) {
	int offset = nMotorEncoder[wheelA];
	int speed=0;
	while(nMotorEncoder[wheelA]-offset < aTicks-SLOW_DOWN) {
		if(speed<MAX_SPEED)speed++;
		cDir(speed,-speed,-speed,speed);
	}
	while(nMotorEncoder[wheelA]-offset < aTicks) {
		if(speed>MIN_SPEED)speed--;
		cDir(speed,-speed,-speed,speed);
	}
	cDir(0,0,0,0);
}

void spinRight(int aTicks){
	int offset = nMotorEncoder[wheelA];
	int speed=0;
	while(nMotorEncoder[wheelA]-offset > -aTicks+SLOW_DOWN) {
		if(speed<MAX_SPEED)speed++;
		cDir(-speed,-speed,-speed,-speed);
	}
	while(nMotorEncoder[wheelA]-offset < aTicks) {
		if(speed>MIN_SPEED)speed--;
		cDir(-speed,-speed,-speed,-speed);
	}
	cDir(0,0,0,0);
}

void realign() {
	int offset = nMotorEncoder[wheelA];
	int speed=0;
	while(nMotorEncoder[wheelA]-offset < LEFT_ALIGN) {
		if(speed<MAX_SPEED)speed++;
		cDir(speed,-speed,-speed,speed);
	}
	offset = nMotorEncoder[wheelA];
	speed=0;
	while(-nMotorEncoder[wheelA]-offset < LEFT_REALIGN) {
		if(speed<MAX_SPEED)speed++;
		cDir(speed,-speed,-speed,speed);
	}
}

int getCenterThingPos() {
	int answer = 1;

	return answer;
}
task main() {
	nMotorEncoder[wheelC]=0;
	driveForward(FORWARD_DRIVE);
	switch(getCenterThingPos()) {
		case 1:
			goLeft(ONE_LEFT_DRIVE);
			spinRight(ONE_SPIN);
			driveBackward(ONE_BACK_DRIVE);
			realign();
			break;
		case 2:
			spinRight(TWO_SPIN);
			driveBackward(TWO_BACK_DRIVE);
			realign();
			break;
		case 3:
			spinRight(THREE_SPIN);
			realign();
			break;
		default:
			break;
	}
}
